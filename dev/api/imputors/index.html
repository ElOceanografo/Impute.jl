<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imputors · Impute.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Impute.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Walkthroughs</span><ul><li><a class="toctext" href="../../walkthroughs/spatiotemporal/">Spatiotemporal</a></li><li><a class="toctext" href="../../walkthroughs/svd/">SVD</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../impute/">Impute</a></li><li><a class="toctext" href="../assertions/">Assertions</a></li><li><a class="toctext" href="../filter/">Filter</a></li><li class="current"><a class="toctext" href>Imputors</a><ul class="internal"><li><a class="toctext" href="#Standardize-1">Standardize</a></li><li><a class="toctext" href="#Replace-1">Replace</a></li><li><a class="toctext" href="#Substitute-1">Substitute</a></li><li><a class="toctext" href="#Simple-Random-Sample-(SRS)-1">Simple Random Sample (SRS)</a></li><li><a class="toctext" href="#Interpolate-1">Interpolate</a></li><li><a class="toctext" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></li><li><a class="toctext" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></li><li><a class="toctext" href="#K-Nearest-Neighbors-(KNN)-1">K-Nearest Neighbors (KNN)</a></li><li><a class="toctext" href="#SVD-1">SVD</a></li></ul></li><li><a class="toctext" href="../chain/">Chain</a></li><li><a class="toctext" href="../functional/">Functional</a></li><li><a class="toctext" href="../utils/">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Imputors</a></li></ul><a class="edit-page" href="https://github.com/invenia/Impute.jl/blob/master/docs/src/api/imputors.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Imputors</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Imputors-1" href="#Imputors-1">Imputors</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Imputor" href="#Impute.Imputor"><code>Impute.Imputor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Imputor</code></pre><p>An imputor stores information about imputing values in <code>AbstractArray</code>s and <code>Tables.table</code>s. New imputation methods are expected to subtype <code>Imputor</code> and, at minimum, implement the <code>_impute!(data::AbstractArrays, imp::&lt;MyImputor&gt;)</code> method.</p><p>While fallback <code>impute</code> and <code>impute!</code> methods are provided to extend your <code>_impute!</code> methods to n-dimensional arrays and tables, you can always override these methods to change the behaviour as necessary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{AbstractArray,Impute.Imputor}" href="#Impute.impute!-Tuple{AbstractArray,Impute.Imputor}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(data::AbstractArray, imp) -&gt; data</code></pre><p>Just returns the <code>data</code> when the array doesn&#39;t contain <code>missing</code>s</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL162-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{AbstractArray{Missing,N} where N,Impute.Imputor}" href="#Impute.impute!-Tuple{AbstractArray{Missing,N} where N,Impute.Imputor}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(data::AbstractArray{Missing}, imp) -&gt; data</code></pre><p>Just return the <code>data</code> when the array only contains <code>missing</code>s</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL170-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Union{Tuple{A}, Tuple{T}, Tuple{A,Impute.Imputor}} where A&lt;:(AbstractArray{Union{Missing, T},N} where N) where T" href="#Impute.impute!-Union{Tuple{A}, Tuple{T}, Tuple{A,Impute.Imputor}} where A&lt;:(AbstractArray{Union{Missing, T},N} where N) where T"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(data::A, imp; dims=:, kwargs...) -&gt; A</code></pre><p>Impute the <code>missing</code> values in the array <code>data</code> using the imputor <code>imp</code>. Optionally, you can specify the dimension to impute along.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray{Union{T, Missing}}</code>: the data to be impute along dimensions <code>dims</code></li><li><code>imp::Imputor</code>: the Imputor method to use</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dims=:</code>: The dimension to impute along. <code>:rows</code> and <code>:cols</code> are also supported for matrices.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{Union{T, Missing}}</code>: the input <code>data</code> with values imputed</li></ul><p><strong>NOTES</strong></p><ol><li>Matrices have a deprecated <code>dims=2</code> special case as <code>dims=:</code> is a breaking change</li><li>Mutation isn&#39;t guaranteed for all array types, hence we return the result</li><li><code>eachslice</code> is used internally which requires Julia 1.1</li></ol><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Interpolate, impute!

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute!(M, Interpolate(); dims=1)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5

julia&gt; M
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL83-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Union{Tuple{T}, Tuple{T,Impute.Imputor}} where T" href="#Impute.impute!-Union{Tuple{T}, Tuple{T,Impute.Imputor}} where T"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(table, imp; cols=nothing) -&gt; table</code></pre><p>Imputes the data in a table by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Imputor</code>: the Imputor method to use</li><li><code>table</code>: the data to impute</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>cols</code>: The columns to impute along (default is to impute all columns)</li></ul><p><strong>Returns</strong></p><ul><li>the input <code>data</code> with values imputed</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames; using Impute: Interpolate, impute

julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5])
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │

julia&gt; impute(df, Interpolate())
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ 3.0      │ 3.3      │
│ 4   │ 4.0      │ 4.4      │
│ 5   │ 5.0      │ 5.5      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL178-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Union{Tuple{T}, Tuple{T,Impute.Imputor}} where T&lt;:(AbstractArray{var&quot;#s19&quot;,1} where var&quot;#s19&quot;&lt;:NamedTuple)" href="#Impute.impute!-Union{Tuple{T}, Tuple{T,Impute.Imputor}} where T&lt;:(AbstractArray{var&quot;#s19&quot;,1} where var&quot;#s19&quot;&lt;:NamedTuple)"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(data::T, imp; kwargs...) -&gt; T where T &lt;: AbstractVector{&lt;:NamedTuple}</code></pre><p>Special case rowtables which are arrays, but we want to fallback to the tables method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL153-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute-Tuple{Any,Impute.Imputor}" href="#Impute.impute-Tuple{Any,Impute.Imputor}"><code>Impute.impute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute(data::T, imp; kwargs...) -&gt; T</code></pre><p>Returns a new copy of the <code>data</code> with the missing data imputed by the imputor <code>imp</code>. For matrices and tables, data is imputed one variable/column at a time. If this is not the desired behaviour then you should overload this method or specify a different <code>dims</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: the data to be impute</li><li><code>imp::Imputor</code>: the Imputor method to use</li></ul><p><strong>Returns</strong></p><ul><li>the input <code>data</code> with values imputed</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Interpolate, impute

julia&gt; v = [1.0, 2.0, missing, missing, 5.0]
5-element Array{Union{Missing, Float64},1}:
 1.0
 2.0
  missing
  missing
 5.0

julia&gt; impute(v, Interpolate())
5-element Array{Union{Missing, Float64},1}:
 1.0
 2.0
 3.0
 4.0
 5.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors.jl#LL41-L75">source</a></section><h2><a class="nav-anchor" id="Standardize-1" href="#Standardize-1">Standardize</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Standardize" href="#Impute.Standardize"><code>Impute.Standardize</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Standardize(; values)</code></pre><p>Standardize (or replace) various missing data values with <code>missing</code>. This is useful for downstream imputation methods that assume missing data is represented by a <code>missing</code>.</p><p>!!! In-place methods are only applicable for datasets which already <code>allowmissing</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>value::Tuple</code>: A tuple of values that should be considered <code>missing</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Standardize, impute

julia&gt; M = [1.0 2.0 -9999.0 NaN 5.0; 1.1 2.2 3.3 0.0 5.5]
2×5 Array{Float64,2}:
 1.0  2.0  -9999.0  NaN    5.0
 1.1  2.2      3.3    0.0  5.5

julia&gt; impute(M, Standardize(; values=(NaN, -9999.0, 0.0)))
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/standardize.jl#LL1-L27">source</a></section><h2><a class="nav-anchor" id="Replace-1" href="#Replace-1">Replace</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Replace" href="#Impute.Replace"><code>Impute.Replace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Replace(; value)</code></pre><p>Replace <code>missing</code>s with one of the specified constant values, depending on the input type. If multiple values of the same type are provided then the first one will be used. If the input data is of a different type then the no replacement will be performed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>values::Tuple</code>: A scalar or tuple of different values that should be used to replace missings. Typically, one value per type you&#39;re considering imputing for.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Replace, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, Replace(; values=0.0); dims=2)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  0.0  0.0  5.0
 1.1  2.2  3.3  0.0  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/replace.jl#LL1-L26">source</a></section><h2><a class="nav-anchor" id="Substitute-1" href="#Substitute-1">Substitute</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Substitute" href="#Impute.Substitute"><code>Impute.Substitute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Substitute(; statistic=nothing)
Substitute(; robust=true, weights=nothing)</code></pre><p>Substitute missing values with a summary statistic over the non-missing values.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>statistic</code>: A summary statistic function to be applied to the non-missing values. This function should return a value of the same type as the input data <code>eltype</code>. If this function isn&#39;t passed in then the <code>defaultstats</code> function is used to make a best guess.</li><li><code>robust</code>: Whether to use <code>median</code> or <code>mean</code> for continuous datasets in <code>defaultstats</code></li><li><code>weights</code>: A set of statistical weights to apply to the <code>mean</code> or <code>median</code> in <code>defaultstats</code>.</li></ul><p><strong>Default Rules</strong></p><p>Our default substitution rules defined in <code>defaultstats</code> are as follows:</p><ul><li><code>mode</code> applies to non-<code>Real</code>s, <code>Bool</code>s, and <code>Integers</code> with few unique values.</li><li><code>median</code> is used for all other <code>Real</code> values that aren&#39;t restricted by the above rules. Optionally, <code>mean</code> can be used if <code>robust=false</code>. If statistical <code>weights</code> are passed in then a weighted <code>mean</code>/<code>median</code> will be calculated.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Statistics; using Impute: Substitute, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, Substitute(; statistic=mean ∘ skipmissing); dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  2.66667  2.66667  5.0
 1.1  2.2  3.3      3.025    5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/substitute.jl#LL1-L37">source</a></section><h2><a class="nav-anchor" id="Simple-Random-Sample-(SRS)-1" href="#Simple-Random-Sample-(SRS)-1">Simple Random Sample (SRS)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.SRS-Tuple{}" href="#Impute.SRS-Tuple{}"><code>Impute.SRS</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SRS(; rng=Random.GLOBAL_RNG)</code></pre><p>Simple Random Sampling (SRS) imputation is a method for imputing both continuous and categorical variables. Furthermore, it completes imputation while preserving the distributional properties of the variables (e.g., mean, standard deviation).</p><p>The basic idea is that for a given variable, <code>x</code>, with missing data, we randomly draw from the observed values of <code>x</code> to impute the missing elements. Since the random draws from <code>x</code> for imputation are done in proportion to the frequency distribution of the values in <code>x</code>, the univariate distributional properties are generally not impacted; this is true for both categorical and continuous data.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: A random number generator to use for observation selection</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Random; using Impute: SRS, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, SRS(; rng=MersenneTwister(1234)); dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  1.0  2.0  5.0
 1.1  2.2  3.3  3.3  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/srs.jl#LL8-L39">source</a></section><h2><a class="nav-anchor" id="Interpolate-1" href="#Interpolate-1">Interpolate</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Interpolate" href="#Impute.Interpolate"><code>Impute.Interpolate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Interpolate()</code></pre><p>Performs linear interpolation between the nearest values in an vector. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p>!!! Missing values at the head or tail of the array cannot be interpolated if there are no existing values on both sides. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Interpolate, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, Interpolate(); dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/interp.jl#LL1-L26">source</a></section><h2><a class="nav-anchor" id="Last-Observation-Carried-Forward-(LOCF)-1" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.LOCF" href="#Impute.LOCF"><code>Impute.LOCF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LOCF())</code></pre><p>Last observation carried forward (LOCF) iterates forwards through the <code>data</code> and fills missing data with the last existing observation. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p>See also:</p><ul><li><a href="api/@ref">NOCB</a>: Next Observation Carried Backward</li></ul><p>!!! Missing elements at the head of the array may not be imputed if there is no existing observation to carry forward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: LOCF, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, LOCF(); dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  2.0  2.0  5.0
 1.1  2.2  3.3  3.3  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/locf.jl#LL1-L29">source</a></section><h2><a class="nav-anchor" id="Next-Observation-Carried-Backward-(NOCB)-1" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.NOCB" href="#Impute.NOCB"><code>Impute.NOCB</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NOCB()</code></pre><p>Next observation carried backward (NOCB) iterates backwards through the <code>data</code> and fills missing data with the next existing observation.</p><p>See also:</p><ul><li><a href="api/@ref">LOCF</a>: Last Observation Carried Forward</li></ul><p>!!! Missing elements at the tail of the array may not be imputed if there is no existing observation to carry backward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: NOCB, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, NOCB(); dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  5.0  5.0  5.0
 1.1  2.2  3.3  5.5  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/nocb.jl#LL1-L30">source</a></section><h2><a class="nav-anchor" id="K-Nearest-Neighbors-(KNN)-1" href="#K-Nearest-Neighbors-(KNN)-1">K-Nearest Neighbors (KNN)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.KNN" href="#Impute.KNN"><code>Impute.KNN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">KNN(; kwargs...)</code></pre><p>Imputation using k-Nearest Neighbor algorithm.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>k::Int</code>: number of nearest neighbors</li><li><code>dist::MinkowskiMetric</code>: distance metric suppports by <code>NearestNeighbors.jl</code> (Euclidean, Chebyshev, Minkowski and Cityblock)</li><li><code>threshold::AbstractFloat</code>: threshold for missing neighbors</li></ul><p><strong>Reference</strong></p><ul><li>Troyanskaya, Olga, et al. &quot;Missing value estimation methods for DNA microarrays.&quot; Bioinformatics 17.6 (2001): 520-525.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/knn.jl#LL1-L13">source</a></section><h2><a class="nav-anchor" id="SVD-1" href="#SVD-1">SVD</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.SVD" href="#Impute.SVD"><code>Impute.SVD</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SVD(; kwargs...)</code></pre><p>Imputes the missing values in a matrix using an expectation maximization (EM) algorithm over low-rank SVD approximations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>init::Imputor</code>: initialization method for missing values (default: Substitute())</li><li><code>rank::Union{Int, Nothing}</code>: rank of the SVD approximation (default: nothing meaning start and 0 and increase)</li><li><code>tol::Float64</code>: convergence tolerance (default: 1e-10)</li><li><code>maxiter::Int</code>: Maximum number of iterations if convergence is not achieved (default: 100)</li><li><code>limits::Unoin{Tuple{Float64, Float64}, Nothing}</code>: Bound the possible approximation values (default: nothing)</li><li><code>verbose::Bool</code>: Whether to display convergence progress (default: true)</li></ul><p><strong>References</strong></p><ul><li>Troyanskaya, Olga, et al. &quot;Missing value estimation methods for DNA microarrays.&quot; Bioinformatics 17.6 (2001): 520-525.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/ddc92f17b03487a604e53c39cfabefb4ce47c180/src/imputors/svd.jl#LL1-L17">source</a></section><footer><hr/><a class="previous" href="../filter/"><span class="direction">Previous</span><span class="title">Filter</span></a><a class="next" href="../chain/"><span class="direction">Next</span><span class="title">Chain</span></a></footer></article></body></html>
