<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imputors · Impute.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Impute.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../impute/">Impute</a></li><li><a class="toctext" href="../context/">Context</a></li><li class="current"><a class="toctext" href>Imputors</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Fill-1">Fill</a></li><li class="toplevel"><a class="toctext" href="#Interpolate-1">Interpolate</a></li><li class="toplevel"><a class="toctext" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></li><li class="toplevel"><a class="toctext" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></li><li class="toplevel"><a class="toctext" href="#Chain-1">Chain</a></li></ul></li><li><a class="toctext" href="../utils/">Utilities</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Imputors</a></li></ul><a class="edit-page" href="https://github.com/invenia/Impute.jl/blob/master/docs/src/api/imputors.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Imputors</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{AbstractArray{T,2} where T,Impute.Imputor}" href="#Impute.impute!-Tuple{AbstractArray{T,2} where T,Impute.Imputor}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(data::AbstractMatrix, imp::Imputor; kwargs...)</code></pre><p>Impute the data in a matrix by imputing the values one variable at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractMatrix</code>: the data to impute</li><li><code>imp::Imputor</code>: the Imputor method to use</li></ul><p><strong>Keywords</strong></p><ul><li><code>dims</code>: The dimension to impute along (e.g., observations dim)</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix</code>: the input <code>data</code> with values imputed</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Interpolate, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, Interpolate(; context=Context(; limit=1.0)); dims=2)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors.jl#LL79-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Any,Impute.Imputor}" href="#Impute.impute!-Tuple{Any,Impute.Imputor}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(table, imp::Imputor)</code></pre><p>Imputes the data in a table by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Imputor</code>: the Imputor method to use</li><li><code>table</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li>the input <code>data</code> with values imputed</li></ul><p><strong>Example</strong></p><p>``jldoctest julia&gt; using DataFrames; using Impute: Interpolate, Context, impute julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5]) 5×2 DataFrame │ Row │ a        │ b        │ │     │ Float64⍰ │ Float64⍰ │ ├─────┼──────────┼──────────┤ │ 1   │ 1.0      │ 1.1      │ │ 2   │ 2.0      │ 2.2      │ │ 3   │ missing  │ 3.3      │ │ 4   │ missing  │ missing  │ │ 5   │ 5.0      │ 5.5      │</p><p>julia&gt; impute(df, Interpolate(; context=Context(; limit=1.0))) 5×2 DataFrame │ Row │ a        │ b        │ │     │ Float64⍰ │ Float64⍰ │ ├─────┼──────────┼──────────┤ │ 1   │ 1.0      │ 1.1      │ │ 2   │ 2.0      │ 2.2      │ │ 3   │ 3.0      │ 3.3      │ │ 4   │ 4.0      │ 4.4      │ │ 5   │ 5.0      │ 5.5      │</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors.jl#LL117-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute-Tuple{Any,Impute.Imputor}" href="#Impute.impute-Tuple{Any,Impute.Imputor}"><code>Impute.impute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute(data, imp::Imputor; kwargs...)</code></pre><p>Returns a new copy of the <code>data</code> with the missing data imputed by the imputor <code>imp</code>.</p><p><strong>Keywords</strong></p><ul><li><code>dims</code>: The dimension to impute along (e.g., observations dim)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors.jl#LL66-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Imputor" href="#Impute.Imputor"><code>Impute.Imputor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Imputor</code></pre><p>An imputor stores information about imputing values in <code>AbstractArray</code>s and <code>Tables.table</code>s. New imputation methods are expected to sutype <code>Imputor</code> and, at minimum, implement the <code>impute!(imp::&lt;MyImputor&gt;, data::AbstractVector)</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors.jl#LL1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.splitkwargs-Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T&lt;:Impute.Imputor" href="#Impute.splitkwargs-Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T&lt;:Impute.Imputor"><code>Impute.splitkwargs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">splitkwargs(::Type{T}, kwargs...) where T &lt;: Imputor -&gt; (imp, rem)</code></pre><p>Takes an Imputor type with kwargs and returns the constructed imputor and the unused kwargs which should be passed to the <code>impute!</code> call.</p><p>NOTE: This is used by utility methods with construct and imputor and call impute in 1 call.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors.jl#LL32-L39">source</a></section><h1><a class="nav-anchor" id="Drop-1" href="#Drop-1">Drop</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.DropObs" href="#Impute.DropObs"><code>Impute.DropObs</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DropObs(; context=Context)</code></pre><p>Removes missing observations from the <code>AbstractArray</code> or <code>Tables.table</code> provided.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext=Context()</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: DropObs, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, DropObs(; context=Context(; limit=1.0)); dims=2)
2×3 Array{Union{Missing, Float64},2}:
 1.0  2.0  5.0
 1.1  2.2  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/drop.jl#LL1-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.DropVars" href="#Impute.DropVars"><code>Impute.DropVars</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DropVars(; context=Context())</code></pre><p>Finds variables with too many missing values in a <code>AbstractMatrix</code> or <code>Tables.table</code> and removes them from the input data.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: DropVars, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, DropVars(; context=Context(; limit=0.2)); dims=2)
1×5 Array{Union{Missing, Float64},2}:
 1.1  2.2  3.3  missing  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/drop.jl#LL66-L90">source</a></section><h1><a class="nav-anchor" id="Fill-1" href="#Fill-1">Fill</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Fill" href="#Impute.Fill"><code>Impute.Fill</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Fill(; value=mean, context=Context())</code></pre><p>Fills in the missing data with a specific value. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>value::Any</code>: A scalar or a function that returns a scalar if passed the data with missing data removed (e.g, <code>mean</code>)</li><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Fill, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, Fill(; context=Context(; limit=1.0)); dims=2)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  2.66667  2.66667  5.0
 1.1  2.2  3.3      3.025    5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/fill.jl#LL1-L28">source</a></section><h1><a class="nav-anchor" id="Interpolate-1" href="#Interpolate-1">Interpolate</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Interpolate" href="#Impute.Interpolate"><code>Impute.Interpolate</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Interpolate(; context=Context())</code></pre><p>Performs linear interpolation between the nearest values in an vector. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p>WARNING: Missing values at the head or tail of the array cannot be interpolated if there are no existing values on both sides. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: Interpolate, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, Interpolate(; context=Context(; limit=1.0)); dims=2)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/interp.jl#LL1-L30">source</a></section><h1><a class="nav-anchor" id="Last-Observation-Carried-Forward-(LOCF)-1" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.LOCF" href="#Impute.LOCF"><code>Impute.LOCF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LOCF(; context=Context())</code></pre><p>Last observation carried forward (LOCF) iterates forwards through the <code>data</code> and fills missing data with the last existing observation. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p>See also:</p><ul><li><a href="api/@ref">NOCB</a>: Next Observation Carried Backward</li></ul><p>WARNING: missing elements at the head of the array may not be imputed if there is no existing observation to carry forward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: LOCF, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, LOCF(; context=Context(; limit=1.0)); dims=2)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  2.0  2.0  5.0
 1.1  2.2  3.3  3.3  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/locf.jl#LL1-L33">source</a></section><h1><a class="nav-anchor" id="Next-Observation-Carried-Backward-(NOCB)-1" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.NOCB" href="#Impute.NOCB"><code>Impute.NOCB</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NOCB(; context=Context())</code></pre><p>Next observation carried backward (NOCB) iterates backwards through the <code>data</code> and fills missing data with the next existing observation.</p><p>See also:</p><ul><li><a href="api/@ref">LOCF</a>: Last Observation Carried Forward</li></ul><p>WARNING: missing elements at the tail of the array may not be imputed if there is no existing observation to carry backward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: NOCB, Context, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0   missing  missing  5.0
 1.1  2.2  3.3       missing  5.5

julia&gt; impute(M, NOCB(; context=Context(; limit=1.0)); dims=2)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  5.0  5.0  5.0
 1.1  2.2  3.3  5.5  5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/nocb.jl#LL1-L32">source</a></section><h1><a class="nav-anchor" id="Chain-1" href="#Chain-1">Chain</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.impute!-Tuple{Any,Impute.Chain}" href="#Impute.impute!-Tuple{Any,Impute.Chain}"><code>Impute.impute!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">impute!(data, imp::Chain)</code></pre><p>Runs the <code>Imputor</code>s on the supplied data.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Chain</code>: the chain to run</li><li><code>data</code>: our data to impute</li></ul><p><strong>Returns</strong></p><ul><li>our imputed data</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/chain.jl#LL41-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Chain" href="#Impute.Chain"><code>Impute.Chain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Chain &lt;: Imputor</code></pre><p>Runs multiple <code>Imputor</code>s on the same data in the order they&#39;re provided.</p><p><strong>Fields</strong></p><ul><li><code>imputors::Array{Imputor}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/chain.jl#LL1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.Chain-Tuple{Vararg{Impute.Imputor,N} where N}" href="#Impute.Chain-Tuple{Vararg{Impute.Imputor,N} where N}"><code>Impute.Chain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Chain(imputors::Imputor...) -&gt; Chain</code></pre><p>Creates a Chain using the <code>Imputor</code>s provided (ordering matters).</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/chain.jl#LL13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∘-Tuple{Impute.Imputor,Impute.Imputor}" href="#Base.:∘-Tuple{Impute.Imputor,Impute.Imputor}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compose new <code>Imputor</code> chains with the composition operator</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute: impute, Interpolate, NOCB, LOCF, Context

julia&gt; ctx = Context(; limit=1.0)
Context(0, 0, 1.0, ismissing, Impute.complete)

julia&gt; imp = Interpolate(; context=ctx) ∘ NOCB(; context=ctx) ∘ LOCF(; context=ctx)
Impute.Chain(Impute.Imputor[Interpolate(2, Context(0, 0, 1.0, ismissing, complete)), NOCB(2, Context(0, 0, 1.0, ismissing, complete)), LOCF(2, Context(0, 0, 1.0, ismissing, complete))])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/a31be5c44f93a0d462bbc44919a873c87d091a0f/src/imputors/chain.jl#LL20-L34">source</a></section><footer><hr/><a class="previous" href="../context/"><span class="direction">Previous</span><span class="title">Context</span></a><a class="next" href="../utils/"><span class="direction">Next</span><span class="title">Utilities</span></a></footer></article></body></html>
