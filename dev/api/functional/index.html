<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functional · Impute.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Impute.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Walkthroughs</span><ul><li><a class="toctext" href="../../walkthroughs/spatiotemporal/">Spatiotemporal</a></li><li><a class="toctext" href="../../walkthroughs/svd/">SVD</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../impute/">Impute</a></li><li><a class="toctext" href="../validators/">Validators</a></li><li><a class="toctext" href="../filter/">Filter</a></li><li><a class="toctext" href="../imputors/">Imputors</a></li><li><a class="toctext" href="../chain/">Chain</a></li><li class="current"><a class="toctext" href>Functional</a><ul class="internal"><li><a class="toctext" href="#Threshold-1">Threshold</a></li><li><a class="toctext" href="#Filter-1">Filter</a></li><li><a class="toctext" href="#DeclareMissings-1">DeclareMissings</a></li><li><a class="toctext" href="#Replace-1">Replace</a></li><li><a class="toctext" href="#Substitute-1">Substitute</a></li><li><a class="toctext" href="#Simple-Random-Sample-(SRS)-1">Simple Random Sample (SRS)</a></li><li><a class="toctext" href="#Interpolate-1">Interpolate</a></li><li><a class="toctext" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></li><li><a class="toctext" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></li><li><a class="toctext" href="#K-Nearest-Neighbors-(KNN)-1">K-Nearest Neighbors (KNN)</a></li><li><a class="toctext" href="#SVD-1">SVD</a></li></ul></li><li><a class="toctext" href="../utils/">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Functional</a></li></ul><a class="edit-page" href="https://github.com/invenia/Impute.jl/blob/master/docs/src/api/functional.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functional</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functional-1" href="#Functional-1">Functional</a></h1><p>To reduce verbosity, Impute.jl also provides a functional interface to its <code>Validator</code>s, <code>Filter</code>s, <code>Imputor</code>s, etc.</p><p>Ex)</p><pre><code class="language-julia-repl">julia&gt; using Impute: Interpolate, impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5];

julia&gt; impute(M, Interpolate(); dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5</code></pre><p>Can also be written as</p><pre><code class="language-julia-repl">julia&gt; using Impute

julia&gt; M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5];

julia&gt; Impute.interp(M; dims=:rows)
2×5 Array{Union{Missing, Float64},2}:
 1.0  2.0  3.0  4.0  5.0
 1.1  2.2  3.3  4.4  5.5</code></pre><h2><a class="nav-anchor" id="Threshold-1" href="#Threshold-1">Threshold</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.threshold" href="#Impute.threshold"><code>Impute.threshold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.threshold(data; ratio=0.1, weights=nothing, kwargs...)</code></pre><p>Assert that proportion of missing values in the <code>data</code> do not exceed the <code>ratio</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames, Impute

julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5])
5×2 DataFrames.DataFrame
│ Row │ a        │ b        │
│     │ Float64  │ Float64  │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │

julia&gt; Impute.threshold(df)
ERROR: ThresholdError: Ratio of missing values exceeded 0.1 (0.4)
Stacktrace:
...

julia&gt; Impute.threshold(df; ratio=0.8)
5×2 DataFrames.DataFrame
│ Row │ a        │ b        │
│     │ Float64  │ Float64  │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL94-L130">source</a></section><h2><a class="nav-anchor" id="Filter-1" href="#Filter-1">Filter</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.filter" href="#Impute.filter"><code>Impute.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.filter([f,] data; dims)</code></pre><p>Filters values, rows, columns or slices of data that should be removed. The default function <code>f</code> will removing <code>missing</code>s, or any rows, columns or slices containing <code>missing</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames; using Impute: Impute


julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5])
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │

julia&gt; Impute.filter(df; dims=:cols)
0×0 DataFrame

julia&gt; Impute.filter(df; dims=:rows)
3×2 DataFrame
│ Row │ a       │ b       │
│     │ Float64 │ Float64 │
├─────┼─────────┼─────────┤
│ 1   │ 1.0     │ 1.1     │
│ 2   │ 2.0     │ 2.2     │
│ 3   │ 5.0     │ 5.5     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL195-L230">source</a></section><h2><a class="nav-anchor" id="DeclareMissings-1" href="#DeclareMissings-1">DeclareMissings</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.declaremissings" href="#Impute.declaremissings"><code>Impute.declaremissings</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.declaremissings(data; values)</code></pre><p>DeclareMissings (or replace) various missing data representations with <code>missing</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>value::Tuple</code>: A tuple of values that should be considered <code>missing</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames, Impute

julia&gt; df = DataFrame(
           :a =&gt; [1.1, 2.2, NaN, NaN, 5.5],
           :b =&gt; [1, 2, 3, -9999, 5],
           :c =&gt; [&quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;NULL&quot;],
       )
5×3 DataFrame
│ Row │ a       │ b     │ c      │
│     │ Float64 │ Int64 │ String │
├─────┼─────────┼───────┼────────┤
│ 1   │ 1.1     │ 1     │ v      │
│ 2   │ 2.2     │ 2     │ w      │
│ 3   │ NaN     │ 3     │ x      │
│ 4   │ NaN     │ -9999 │ y      │
│ 5   │ 5.5     │ 5     │ NULL   │

julia&gt; Impute.declaremissings(df; values=(NaN, -9999, &quot;NULL&quot;))
5×3 DataFrame
│ Row │ a        │ b       │ c       │
│     │ Float64? │ Int64?  │ String? │
├─────┼──────────┼─────────┼─────────┤
│ 1   │ 1.1      │ 1       │ v       │
│ 2   │ 2.2      │ 2       │ w       │
│ 3   │ missing  │ 3       │ x       │
│ 4   │ missing  │ missing │ y       │
│ 5   │ 5.5      │ 5       │ missing │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL404-L442">source</a></section><h2><a class="nav-anchor" id="Replace-1" href="#Replace-1">Replace</a></h2><pre><code class="language-docs">Impute.replace</code></pre><h2><a class="nav-anchor" id="Substitute-1" href="#Substitute-1">Substitute</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.substitute" href="#Impute.substitute"><code>Impute.substitute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.substitute(data; statistic=nothing)
Impute.substitute(data; robust=true, weights=nothing)</code></pre><p>Substitute missing values with a summary statistic over the non-missing values.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>statistic</code>: A summary statistic function to be applied to the non-missing values. This function should return a value of the same type as the input data <code>eltype</code>. If this function isn&#39;t passed in then the <code>defaultstats</code> function is used to make a best guess.</li><li><code>robust</code>: Whether to use <code>median</code> or <code>mean</code> for continuous datasets in <code>defaultstats</code></li><li><code>weights</code>: A set of statistical weights to apply to the <code>mean</code> or <code>median</code> in <code>defaultstats</code>.</li></ul><p>See <a href="api/@ref">Substitute</a> for details on substitution rules defined in <code>defaultstats</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames, Impute

julia&gt; df = DataFrame(
                  :a =&gt; [8.9, 2.2, missing, missing, 1.3, 6.2, 3.7, 4.8],
                  :b =&gt; [2, 6, 3, missing, 7, 1, 9, missing],
                  :c =&gt; [true, false, true, true, false, missing, false, true],
              )
8×3 DataFrame
│ Row │ a        │ b       │ c       │
│     │ Float64? │ Int64?  │ Bool?   │
├─────┼──────────┼─────────┼─────────┤
│ 1   │ 8.9      │ 2       │ 1       │
│ 2   │ 2.2      │ 6       │ 0       │
│ 3   │ missing  │ 3       │ 1       │
│ 4   │ missing  │ missing │ 1       │
│ 5   │ 1.3      │ 7       │ 0       │
│ 6   │ 6.2      │ 1       │ missing │
│ 7   │ 3.7      │ 9       │ 0       │
│ 8   │ 4.8      │ missing │ 1       │

julia&gt; Impute.substitute(df)
8×3 DataFrame
│ Row │ a        │ b      │ c     │
│     │ Float64? │ Int64? │ Bool? │
├─────┼──────────┼────────┼───────┤
│ 1   │ 8.9      │ 2      │ 1     │
│ 2   │ 2.2      │ 6      │ 0     │
│ 3   │ 4.25     │ 3      │ 1     │
│ 4   │ 4.25     │ 4      │ 1     │
│ 5   │ 1.3      │ 7      │ 0     │
│ 6   │ 6.2      │ 1      │ 1     │
│ 7   │ 3.7      │ 9      │ 0     │
│ 8   │ 4.8      │ 4      │ 1     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL444-L496">source</a></section><h2><a class="nav-anchor" id="Simple-Random-Sample-(SRS)-1" href="#Simple-Random-Sample-(SRS)-1">Simple Random Sample (SRS)</a></h2><pre><code class="language-docs">Impute.srs</code></pre><h2><a class="nav-anchor" id="Interpolate-1" href="#Interpolate-1">Interpolate</a></h2><pre><code class="language-docs">Impute.interp</code></pre><h2><a class="nav-anchor" id="Last-Observation-Carried-Forward-(LOCF)-1" href="#Last-Observation-Carried-Forward-(LOCF)-1">Last Observation Carried Forward (LOCF)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.locf" href="#Impute.locf"><code>Impute.locf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.locf(data; dims=1)</code></pre><p>Iterates forwards through the <code>data</code> and fills missing data with the last existing observation. See <a href="api/@ref">LOCF</a> for details.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames; using Impute: Impute

julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5])
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │

julia&gt; Impute.locf(df)
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ 2.0      │ 3.3      │
│ 4   │ 2.0      │ 3.3      │
│ 5   │ 5.0      │ 5.5      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL301-L333">source</a></section><h2><a class="nav-anchor" id="Next-Observation-Carried-Backward-(NOCB)-1" href="#Next-Observation-Carried-Backward-(NOCB)-1">Next Observation Carried Backward (NOCB)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.nocb" href="#Impute.nocb"><code>Impute.nocb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.nocb(data; dims=1)</code></pre><p>Iterates backwards through the <code>data</code> and fills missing data with the next existing observation. See <a href="api/@ref">LOCF</a> for details.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using DataFrames; using Impute: Impute

julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5])
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │

julia&gt; Impute.nocb(df)
5×2 DataFrame
│ Row │ a        │ b        │
│     │ Float64? │ Float64? │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ 5.0      │ 3.3      │
│ 4   │ 5.0      │ 5.5      │
│ 5   │ 5.0      │ 5.5      │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL335-L367">source</a></section><h2><a class="nav-anchor" id="K-Nearest-Neighbors-(KNN)-1" href="#K-Nearest-Neighbors-(KNN)-1">K-Nearest Neighbors (KNN)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.knn" href="#Impute.knn"><code>Impute.knn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.knn(; k=1, threshold=0.5, dist=Euclidean())</code></pre><p>Imputation using k-Nearest Neighbor algorithm.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>k::Int</code>: number of nearest neighbors</li><li><code>dist::MinkowskiMetric</code>: distance metric suppports by <code>NearestNeighbors.jl</code> (Euclidean, Chebyshev, Minkowski and Cityblock)</li><li><code>threshold::AbsstractFloat</code>: thershold for missing neighbors</li></ul><p><strong>Reference</strong></p><ul><li>Troyanskaya, Olga, et al. &quot;Missing value estimation methods for DNA microarrays.&quot; Bioinformatics 17.6 (2001): 520-525.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute, Missings

julia&gt; data = allowmissing(reshape(sin.(1:20), 5, 4)); data[[2, 3, 7, 9, 13, 19]] .= missing; data
5×4 Array{Union{Missing, Float64},2}:
  0.841471  -0.279415  -0.99999   -0.287903
   missing    missing  -0.536573  -0.961397
   missing   0.989358    missing  -0.750987
 -0.756802    missing   0.990607    missing
 -0.958924  -0.544021   0.650288   0.912945

julia&gt; result = Impute.knn(data; dims=:cols)
5×4 Array{Union{Missing, Float64},2}:
  0.841471  -0.279415  -0.99999   -0.287903
 -0.756802   0.989358  -0.536573  -0.961397
 -0.756802   0.989358  -0.536573  -0.750987
 -0.756802  -0.544021   0.990607   0.912945
 -0.958924  -0.544021   0.650288   0.912945</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL498-L531">source</a></section><h2><a class="nav-anchor" id="SVD-1" href="#SVD-1">SVD</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Impute.svd" href="#Impute.svd"><code>Impute.svd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Impute.svd(; kwargs...)</code></pre><p>Imputes the missing values in a matrix using an expectation maximization (EM) algorithm over low-rank SVD approximations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>init::Imputor</code>: initialization method for missing values (default: Substitute())</li><li><code>rank::Union{Int, Nothing}</code>: rank of the SVD approximation (default: nothing meaning start and 0 and increase)</li><li><code>tol::Float64</code>: convergence tolerance (default: 1e-10)</li><li><code>maxiter::Int</code>: Maximum number of iterations if convergence is not achieved (default: 100)</li><li><code>limits::Unoin{Tuple{Float64, Float64}, Nothing}</code>: Bound the possible approximation values (default: nothing)</li><li><code>verbose::Bool</code>: Whether to display convergence progress (default: true)</li></ul><p><strong>References</strong></p><ul><li>Troyanskaya, Olga, et al. &quot;Missing value estimation methods for DNA microarrays.&quot; Bioinformatics 17.6 (2001): 520-525.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Impute, Missings

julia&gt; data = allowmissing(reshape(sin.(1:20), 5, 4)); data[[2, 3, 7, 9, 13, 19]] .= missing; data
5×4 Array{Union{Missing, Float64},2}:
  0.841471  -0.279415  -0.99999   -0.287903
   missing    missing  -0.536573  -0.961397
   missing   0.989358    missing  -0.750987
 -0.756802    missing   0.990607    missing
 -0.958924  -0.544021   0.650288   0.912945

julia&gt; result = Impute.svd(data; dims=:cols)
5×4 Array{Union{Missing, Float64},2}:
  0.841471  -0.279415  -0.99999   -0.287903
  0.220258   0.555829  -0.536573  -0.961397
 -0.372745   0.989358   0.533193  -0.750987
 -0.756802   0.253309   0.990607   0.32315
 -0.958924  -0.544021   0.650288   0.912945</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Impute.jl/blob/0bb27aff5922e3d24d16b1545ad6edb44a156fa7/src/functional.jl#LL533-L570">source</a></section><footer><hr/><a class="previous" href="../chain/"><span class="direction">Previous</span><span class="title">Chain</span></a><a class="next" href="../utils/"><span class="direction">Next</span><span class="title">Utilities</span></a></footer></article></body></html>
