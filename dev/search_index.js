var documenterSearchIndex = {"docs":
[{"location":"#Impute-1","page":"Home","title":"Impute","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using DataFrames, RDatasets, Impute\ndf = dataset(\"boot\", \"neuro\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: stable) (Image: latest) (Image: Build Status) (Image: Build status) (Image: codecov)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Impute.jl provides various methods for handling missing data in Vectors, Matrices and Tables.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"Impute\")","category":"page"},{"location":"#Quickstart-1","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Let's start by loading our dependencies:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using DataFrames, RDatasets, Impute","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We'll also want some test data containing missings to work with:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"df = dataset(\"boot\", \"neuro\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our first instinct might be to drop all observations, but this leaves us too few rows to work with:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Impute.drop(df)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We could try imputing the values with linear interpolation, but that still leaves missing data at the head and tail of our dataset:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Impute.interp(df)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, we can chain multiple simple methods together to give a complete dataset:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Impute.interp(df) |> Impute.locf() |> Impute.nocb()","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Warning:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Your approach should depend on the properties of you data (e.g., MCAR, MAR, MNAR).\nIn-place calls aren't guaranteedto mutate the original data, but it will try avoid copying if possible. In the future, it may be possible to detect whether in-place operations are permitted on an array or table using traits:\nhttps://github.com/JuliaData/Tables.jl/issues/116\nhttps://github.com/JuliaDiffEq/ArrayInterface.jl/issues/22","category":"page"},{"location":"api/impute/#","page":"Impute","title":"Impute","text":"Modules = [Impute]\nPrivate = true\nPages = [\"Impute.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/impute/#Impute.ImputeError","page":"Impute","title":"Impute.ImputeError","text":"ImputeError{T} <: Exception\n\nIs thrown by impute methods when the limit of imputable values has been exceeded.\n\nFields\n\nmsg::T - the message to print.\n\n\n\n\n\n","category":"type"},{"location":"api/impute/#Impute.interp","page":"Impute","title":"Impute.interp","text":"Impute.interp(data; dims=1, context=Context())\n\nPerforms linear interpolation between the nearest values in an vector. See Interpolate for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.interp(df; context=Context(; limit=1.0))\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ 3.0      │ 3.3      │\n│ 4   │ 4.0      │ 4.4      │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/impute/#Impute.dropobs","page":"Impute","title":"Impute.dropobs","text":"Impute.dropobs(data; dims=1, context=Context())\n\nRemoves missing observations from the AbstractArray or Tables.table provided. See DropObs for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.dropobs(df; dims=2, context=Context(; limit=1.0))\n3×2 DataFrames.DataFrame\n│ Row │ a       │ b       │\n│     │ Float64 │ Float64 │\n├─────┼─────────┼─────────┤\n│ 1   │ 1.0     │ 1.1     │\n│ 2   │ 2.0     │ 2.2     │\n│ 3   │ 5.0     │ 5.5     │\n\n\n\n\n\n","category":"function"},{"location":"api/impute/#Impute.dropvars","page":"Impute","title":"Impute.dropvars","text":"Impute.dropvars(data; dims=1, context=Context())\n\nFinds variables with too many missing values in a AbstractMatrix or Tables.table and removes them from the input data. See DropVars for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.dropvars(df; context=Context(; limit=0.2))\n5×1 DataFrames.DataFrame\n│ Row │ b        │\n│     │ Float64⍰ │\n├─────┼──────────┤\n│ 1   │ 1.1      │\n│ 2   │ 2.2      │\n│ 3   │ 3.3      │\n│ 4   │ missing  │\n│ 5   │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/impute/#Impute.fill","page":"Impute","title":"Impute.fill","text":"Impute.fill(data; value=mean, dims=1, context=Context())\n\nFills in the missing data with a specific value. See Fill for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.fill(df; value=-1.0, context=Context(; limit=1.0))\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ -1.0     │ 3.3      │\n│ 4   │ -1.0     │ -1.0     │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/impute/#Impute.locf","page":"Impute","title":"Impute.locf","text":"Impute.locf(data; dims=1, context=Context())\n\nIterates forwards through the data and fills missing data with the last existing observation. See LOCF for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.locf(df; context=Context(; limit=1.0))\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ 2.0      │ 3.3      │\n│ 4   │ 2.0      │ 3.3      │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/impute/#Impute.nocb","page":"Impute","title":"Impute.nocb","text":"Impute.nocb(data; dims=1, context=Context())\n\nIterates backwards through the data and fills missing data with the next existing observation. See LOCF for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.nocb(df; context=Context(; limit=1.0))\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ 5.0      │ 3.3      │\n│ 4   │ 5.0      │ 5.5      │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/impute/#Impute.srs","page":"Impute","title":"Impute.srs","text":"Impute.srs(data; rng=Random.GLOBAL_RNG, context=Context())\n\nSimple Random Sampling (SRS) imputation is a method for imputing both continuous and categorical variables. Furthermore, it completes imputation while preserving the distributional properties of the variables (e.g., mean, standard deviation).\n\nExample\n\njulia> using DataFrames; using Random; using Impute: Impute, Context\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.srs(df; rng=MersenneTwister(1234), context=Context(; limit=1.0))\n5×2 DataFrame\n│ Row │ a        │ b        │\n│     │ Float64⍰ │ Float64⍰ │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ 1.0      │ 3.3      │\n│ 4   │ 5.0      │ 3.3      │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/context/#","page":"Context","title":"Context","text":"Modules = [Impute]\nPages = [\"context.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/context/#Impute.AbstractContext","page":"Context","title":"Impute.AbstractContext","text":"AbstractContext\n\nAn imputation context records summary information about missing data for an imputation algorithm. All AbstractContexts are callable with a function, which allows us to write code like:\n\ncontext() do c\n    # My imputation code using a clean context\nend\n\nThis do-block will pass a fresh context to your code and apply the on_complete function on the resulting data and context state. By default, on_complete will throw an ImputeError if we have too many missing values.\n\n\n\n\n\n","category":"type"},{"location":"api/context/#Impute.Context-Tuple{}","page":"Context","title":"Impute.Context","text":"Context\n\nRecords base information about the missing data and assume all observations are equally weighted.\n\nKeyword Arguments\n\nn::Int: number of observations\ncount::Int: number of missing values found\nlimit::Float64: portion of total values allowed to be imputed (should be between 0.0 and 1.0).\nis_missing::Function: must return a Bool indicating if the value counts as missing\non_complete::Function: a function to run when imputation is complete\n\n\n\n\n\n","category":"method"},{"location":"api/context/#Impute.WeightedContext-Tuple{StatsBase.AbstractWeights}","page":"Context","title":"Impute.WeightedContext","text":"WeightedContext(wv; limit=1.0, is_missing=ismissing, on_complete=complete)\n\nRecords information about the missing data relative to a set of weights. This context type can be useful if some missing observation are more important than others (e.g., more recent observations in time series datasets)\n\nArguments\n\nwv::AbstractWeights: a set of statistical weights to use when evaluating the importance of each observation. Will be accumulated during imputation.\n\nKeyword Arguments\n\nnum::Int: number of observations\ns::Float64: sum of the weights of missing values\nlimit::Float64: portion of total values allowed to be imputed (should be between 0.0 and 1.0).\nis_missing::Function: returns a Bool if the value counts as missing\non_complete::Function: a function to run when imputation is complete\n\n\n\n\n\n","category":"method"},{"location":"api/context/#Base.findfirst-Tuple{Impute.AbstractContext,AbstractArray{T,1} where T}","page":"Context","title":"Base.findfirst","text":"findfirst(ctx::AbstractContext, data::AbstractVector) -> Int\n\nReturns the first non-missing index in data.\n\nArguments\n\nctx::AbstractContext: the context to pass into ismissing!\ndata::AbstractVector: the data array to search\n\nReturns\n\nInt: the first index in data that isn't missing\n\n\n\n\n\n","category":"method"},{"location":"api/context/#Base.findlast-Tuple{Impute.AbstractContext,AbstractArray{T,1} where T}","page":"Context","title":"Base.findlast","text":"findlast(ctx::AbstractContext, data::AbstractVector) -> Int\n\nReturns the last non-missing index in data.\n\nArguments\n\nctx::AbstractContext: the context to pass into ismissing!\ndata::AbstractVector: the data array to search\n\nReturns\n\nInt: the last index in data that isn't missing\n\n\n\n\n\n","category":"method"},{"location":"api/context/#Base.findnext-Tuple{Impute.AbstractContext,AbstractArray{T,1} where T,Int64}","page":"Context","title":"Base.findnext","text":"findnext(ctx::AbstractContext, data::AbstractVector) -> Int\n\nReturns the next non-missing index in data.\n\nArguments\n\nctx::AbstractContext: the context to pass into ismissing!\ndata::AbstractVector: the data array to search\n\nReturns\n\nInt: the next index in data that isn't missing\n\n\n\n\n\n","category":"method"},{"location":"api/context/#Impute.ismissing!-Tuple{Impute.AbstractContext,Any}","page":"Context","title":"Impute.ismissing!","text":"ismissing!(ctx::AbstractContext, x) -> Bool\n\nUses ctx.is_missing to determine if x is missing. If x is a NamedTuple or an AbstractArray then ismissing! will return true if ctx.is_missing returns true for any element. The ctx.count is increased whenever whenever we return true and if ctx.count / ctx.num exceeds our ctx.limit we throw an ImputeError\n\nArguments\n\nctx::Context: the contextual information about missing information.\nx: the value to check (may be an single values, abstract array or row)\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"imputors.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.impute!-Tuple{AbstractArray{T,2} where T,Impute.Imputor}","page":"Imputors","title":"Impute.impute!","text":"impute!(data::AbstractMatrix, imp::Imputor; kwargs...)\n\nImpute the data in a matrix by imputing the values one variable at a time; if this is not the desired behaviour custom imputor methods should overload this method.\n\nArguments\n\ndata::AbstractMatrix: the data to impute\nimp::Imputor: the Imputor method to use\n\nKeywords\n\ndims: The dimension to impute along (e.g., observations dim)\n\nReturns\n\nAbstractMatrix: the input data with values imputed\n\nExample\n\njulia> using Impute: Interpolate, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, Interpolate(; context=Context(; limit=1.0)); dims=2)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  3.0  4.0  5.0\n 1.1  2.2  3.3  4.4  5.5\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#Impute.impute!-Tuple{Any,Impute.Imputor}","page":"Imputors","title":"Impute.impute!","text":"impute!(table, imp::Imputor)\n\nImputes the data in a table by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.\n\nArguments\n\nimp::Imputor: the Imputor method to use\ntable: the data to impute\n\nReturns\n\nthe input data with values imputed\n\nExample\n\n``jldoctest julia> using DataFrames; using Impute: Interpolate, Context, impute julia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5]) 5×2 DataFrame │ Row │ a        │ b        │ │     │ Float64⍰ │ Float64⍰ │ ├─────┼──────────┼──────────┤ │ 1   │ 1.0      │ 1.1      │ │ 2   │ 2.0      │ 2.2      │ │ 3   │ missing  │ 3.3      │ │ 4   │ missing  │ missing  │ │ 5   │ 5.0      │ 5.5      │\n\njulia> impute(df, Interpolate(; context=Context(; limit=1.0))) 5×2 DataFrame │ Row │ a        │ b        │ │     │ Float64⍰ │ Float64⍰ │ ├─────┼──────────┼──────────┤ │ 1   │ 1.0      │ 1.1      │ │ 2   │ 2.0      │ 2.2      │ │ 3   │ 3.0      │ 3.3      │ │ 4   │ 4.0      │ 4.4      │ │ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#Impute.impute-Tuple{Any,Impute.Imputor}","page":"Imputors","title":"Impute.impute","text":"impute(data, imp::Imputor; kwargs...)\n\nReturns a new copy of the data with the missing data imputed by the imputor imp.\n\nKeywords\n\ndims: The dimension to impute along (e.g., observations dim)\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#Impute.Imputor","page":"Imputors","title":"Impute.Imputor","text":"Imputor\n\nAn imputor stores information about imputing values in AbstractArrays and Tables.tables. New imputation methods are expected to sutype Imputor and, at minimum, implement the impute!(imp::<MyImputor>, data::AbstractVector) method.\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Impute.splitkwargs-Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T<:Impute.Imputor","page":"Imputors","title":"Impute.splitkwargs","text":"splitkwargs(::Type{T}, kwargs...) where T <: Imputor -> (imp, rem)\n\nTakes an Imputor type with kwargs and returns the constructed imputor and the unused kwargs which should be passed to the impute! call.\n\nNOTE: This is used by utility methods with construct and imputor and call impute in 1 call.\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#Drop-1","page":"Imputors","title":"Drop","text":"","category":"section"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"drop.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.DropObs","page":"Imputors","title":"Impute.DropObs","text":"DropObs(; context=Context)\n\nRemoves missing observations from the AbstractArray or Tables.table provided.\n\nKeyword Arguments\n\ncontext::AbstractContext=Context(): A context which keeps track of missing data summary information\n\nExample\n\njulia> using Impute: DropObs, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, DropObs(; context=Context(; limit=1.0)); dims=2)\n2×3 Array{Union{Missing, Float64},2}:\n 1.0  2.0  5.0\n 1.1  2.2  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Impute.DropVars","page":"Imputors","title":"Impute.DropVars","text":"DropVars(; context=Context())\n\nFinds variables with too many missing values in a AbstractMatrix or Tables.table and removes them from the input data.\n\nKeyword Arguments\n\ncontext::AbstractContext: A context which keeps track of missing data summary information\n\nExamples\n\njulia> using Impute: DropVars, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, DropVars(; context=Context(; limit=0.2)); dims=2)\n1×5 Array{Union{Missing, Float64},2}:\n 1.1  2.2  3.3  missing  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Fill-1","page":"Imputors","title":"Fill","text":"","category":"section"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"fill.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.Fill","page":"Imputors","title":"Impute.Fill","text":"Fill(; value=mean, context=Context())\n\nFills in the missing data with a specific value. The current implementation is univariate, so each variable in a table or matrix will be handled independently.\n\nKeyword Arguments\n\nvalue::Any: A scalar or a function that returns a scalar if passed the data with missing data removed (e.g, mean)\ncontext::AbstractContext: A context which keeps track of missing data summary information\n\nExample\n\njulia> using Impute: Fill, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, Fill(; context=Context(; limit=1.0)); dims=2)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  2.66667  2.66667  5.0\n 1.1  2.2  3.3      3.025    5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Interpolate-1","page":"Imputors","title":"Interpolate","text":"","category":"section"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"interp.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.Interpolate","page":"Imputors","title":"Impute.Interpolate","text":"Interpolate(; context=Context())\n\nPerforms linear interpolation between the nearest values in an vector. The current implementation is univariate, so each variable in a table or matrix will be handled independently.\n\nWARNING: Missing values at the head or tail of the array cannot be interpolated if there are no existing values on both sides. As a result, this method does not guarantee that all missing values will be imputed.\n\nKeyword Arguments\n\ncontext::AbstractContext: A context which keeps track of missing data summary information\n\nExample\n\njulia> using Impute: Interpolate, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, Interpolate(; context=Context(; limit=1.0)); dims=2)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  3.0  4.0  5.0\n 1.1  2.2  3.3  4.4  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Last-Observation-Carried-Forward-(LOCF)-1","page":"Imputors","title":"Last Observation Carried Forward (LOCF)","text":"","category":"section"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"locf.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.LOCF","page":"Imputors","title":"Impute.LOCF","text":"LOCF(; context=Context())\n\nLast observation carried forward (LOCF) iterates forwards through the data and fills missing data with the last existing observation. The current implementation is univariate, so each variable in a table or matrix will be handled independently.\n\nSee also:\n\nNOCB: Next Observation Carried Backward\n\nWARNING: missing elements at the head of the array may not be imputed if there is no existing observation to carry forward. As a result, this method does not guarantee that all missing values will be imputed.\n\nKeyword Arguments\n\ncontext::AbstractContext: A context which keeps track of missing data summary information\n\nExample\n\njulia> using Impute: LOCF, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, LOCF(; context=Context(; limit=1.0)); dims=2)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  2.0  2.0  5.0\n 1.1  2.2  3.3  3.3  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Next-Observation-Carried-Backward-(NOCB)-1","page":"Imputors","title":"Next Observation Carried Backward (NOCB)","text":"","category":"section"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"nocb.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.NOCB","page":"Imputors","title":"Impute.NOCB","text":"NOCB(; context=Context())\n\nNext observation carried backward (NOCB) iterates backwards through the data and fills missing data with the next existing observation.\n\nSee also:\n\nLOCF: Last Observation Carried Forward\n\nWARNING: missing elements at the tail of the array may not be imputed if there is no existing observation to carry backward. As a result, this method does not guarantee that all missing values will be imputed.\n\nKeyword Arguments\n\ncontext::AbstractContext: A context which keeps track of missing data summary information\n\nExample\n\njulia> using Impute: NOCB, Context, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, NOCB(; context=Context(; limit=1.0)); dims=2)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  5.0  5.0  5.0\n 1.1  2.2  3.3  5.5  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Chain-1","page":"Imputors","title":"Chain","text":"","category":"section"},{"location":"api/imputors/#","page":"Imputors","title":"Imputors","text":"Modules = [Impute]\nPages = [\"chain.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputors/#Impute.impute!-Tuple{Any,Impute.Chain}","page":"Imputors","title":"Impute.impute!","text":"impute!(data, imp::Chain)\n\nRuns the Imputors on the supplied data.\n\nArguments\n\nimp::Chain: the chain to run\ndata: our data to impute\n\nReturns\n\nour imputed data\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#Impute.Chain","page":"Imputors","title":"Impute.Chain","text":"Chain <: Imputor\n\nRuns multiple Imputors on the same data in the order they're provided.\n\nFields\n\nimputors::Array{Imputor}\n\n\n\n\n\n","category":"type"},{"location":"api/imputors/#Impute.Chain-Tuple{Vararg{Impute.Imputor,N} where N}","page":"Imputors","title":"Impute.Chain","text":"Chain(imputors::Imputor...) -> Chain\n\nCreates a Chain using the Imputors provided (ordering matters).\n\n\n\n\n\n","category":"method"},{"location":"api/imputors/#Base.:∘-Tuple{Impute.Imputor,Impute.Imputor}","page":"Imputors","title":"Base.:∘","text":"Compose new Imputor chains with the composition operator\n\nExample\n\njulia> using Impute: impute, Interpolate, NOCB, LOCF, Context\n\njulia> ctx = Context(; limit=1.0)\nContext(0, 0, 1.0, ismissing, Impute.complete)\n\njulia> imp = Interpolate(; context=ctx) ∘ NOCB(; context=ctx) ∘ LOCF(; context=ctx)\nImpute.Chain(Impute.Imputor[Interpolate(2, Context(0, 0, 1.0, ismissing, complete)), NOCB(2, Context(0, 0, 1.0, ismissing, complete)), LOCF(2, Context(0, 0, 1.0, ismissing, complete))])\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#","page":"Utilities","title":"Utilities","text":"Modules = [Impute]\nPages = [\"utils.jl\"]","category":"page"}]
}
